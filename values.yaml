global:
  multitenancy:
    enabled: false
  ingress:
    enabled: false
    className: nginx
    annotations:
      ingress.kubernetes.io/rewrite-target: "/"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
      nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
    host: ""
    tls:
      enabled: false
      secretName: camunda-platform

  elasticsearch:
    ## @param global.elasticsearch.disableExporter if true, disables the elastic exporter in zeebe
    disableExporter: false
    ## @param global.elasticsearch.url can be used to configure the URL to access elasticsearch, if not set services fallback to host and port configuration
    url:
    ## @param global.elasticsearch.protocol defines the elasticsearch access protocol, by default HTTP.
    protocol: http
    ## @param global.elasticsearch.host Elasticsearch.host defines the elasticsearch host, ideally the service name inside the namespace
    host: "{{ .Release.Name }}-elasticsearch"
    ## @param global.elasticsearch.port Elasticsearch.port defines the elasticsearch port, under which elasticsearch can be accessed
    port: 9200
    ## @param global.elasticsearch.clusterName Elasticsearch.clusterName defines the cluster name which is used by Elasticsearch
    clusterName: "elasticsearch"
    ## @param global.elasticsearch.prefix Elasticsearch.prefix defines the prefix which is used by the Zeebe Elasticsearch Exporter to create Elasticsearch indexes
    prefix: zeebe-record
  ## @param global.zeebeClusterName ZeebeClusterName defines the cluster name for the Zeebe cluster. All Zeebe pods get this prefix in their name and the brokers uses that as cluster name.
  zeebeClusterName: "{{ .Release.Name }}-zeebe"
  ## @param global.zeebePort defines the port which is used for the Zeebe Gateway. This port accepts the GRPC Client messages and forwards them to the Zeebe Brokers.
  zeebePort: 26500

  # Identity configuration to configure identity specifics on global level, which can be accessed by other sub-charts
  identity:
    # THIS IS A PRE ALPHA FEATURE, DO NOT USE IT.
    ## @skip global.identity.service
    service:
      ## @skip global.identity.service.url
      url:
    keycloak:
      # Identity.keycloak.internal if true, it will configure an extra service with type "ExternalName".
      ## @param global.identity.keycloak.internal It's useful for using existing Keycloak in another namespace with and access it with the combined Ingress.
      internal: false

    ## @extra global.identity.auth configuration, to configure identity authentication setup
    auth:
      ## @param global.identity.auth.enabled if true, enables the identity authentication otherwise basic-auth will be used on all services.
      enabled: true

      ## @param global.identity.auth.issuer defines the issuer name, which is used by the services to validate the JWT tokens.
      issuer: ""
      ## @param global.identity.auth.issuerBackendUrl defines the issuer backend URL, which is used by the services to validate the JWT tokens in a container to container context.
      issuerBackendUrl: ""
      ## @param global.identity.auth.tokenUrl defines the token URL, which is used by the services to request JWT tokens.
      tokenUrl: ""
      ## @param global.identity.auth.jwksUrl defines the JWKS URL, which is used by the services to validate the JWT tokens.
      jwksUrl: ""
      ## @param global.identity.auth.type defines the type of authentication which should be used. Defaults to Keycloak
      type: "KEYCLOAK"

      #  defines the token issuer (Keycloak) URL, where the services can request JWT tokens.
      # Should be publicly accessible, per default we assume a port-forward to Keycloak (18080) is created before login.
      ## @param global.identity.auth.publicIssuerUrl Can be overwritten if ingress is in use and an external IP is available.
      publicIssuerUrl: "http://localhost:18080/auth/realms/camunda-platform"

      ## @extra global.identity.auth.connectors configuration to configure Connectors authentication specifics on global level, which can be accessed by other sub-charts
      connectors:
        ## @param global.identity.auth.connectors.existingSecret can be used to use an own existing secret. If not set a random secret is generated.
        # The existing secret should contain an `connectors-secret` field, which will be used as secret for the identity-Connectors communication.
        existingSecret: ""

      ## @extra global.identity.auth.operate configuration to configure Operate authentication specifics on global level, which can be accessed by other sub-charts
      operate:
        ## @param global.identity.auth.operate.clientId defines the client id, which is used by Operate in authentication flows.
        clientId: operate
        ## @param global.identity.auth.operate.audience defines the audience, which is used by Operate.
        audience: operate-api
        ## @param global.identity.auth.operate.existingSecret can be used to reference an existing secret. If not set, a random secret is generated.
        # The existing secret should contain an `operate-secret` field, which will be used as secret for the identity-Operate communication.
        existingSecret:
        ## @param global.identity.auth.operate.redirectUrl defines the redirect URL, which is used by Keycloak to access Operate.
        # Should be publicly accessible, the default value works if a port-forward to Operate is created to 8081.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8081"

      ## @extra global.identity.auth.tasklist configuration to configure Tasklist authentication specifics on global level, which can be accessed by other sub-charts
      tasklist:
        ## @param global.identity.auth.tasklist.clientId defines the client id, which is used by Tasklist in authentication flows.
        clientId: tasklist
        ## @param global.identity.auth.tasklist.audience defines the audience, which is used by Tasklist.
        audience: tasklist-api
        ## @param global.identity.auth.tasklist.existingSecret can be used to use an own existing secret. If not set a random secret is generated.
        # The existing secret should contain an `tasklist-secret` field, which will be used as secret for the identity-Tasklist communication.
        existingSecret:
        ## @param global.identity.auth.tasklist.redirectUrl defines the root (or redirect) URL, which is used by Keycloak to access Tasklist.
        # Should be publicly accessible, the default value works if a port-forward to Tasklist is created to 8082.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8082"

      ## @extra global.identity.auth.optimize configuration to configure Optimize authentication specifics on global level, which can be accessed by other sub-charts
      optimize:
        ## @param global.identity.auth.optimize.clientId defines the client id, which is used by Optimize in authentication flows.
        clientId: optimize
        ## @param global.identity.auth.optimize.audience defines the audience, which is used by Optimize.
        audience: optimize-api
        ## @param global.identity.auth.optimize.existingSecret can be used to use an own existing secret. If not set a random secret is generated.
        # The existing secret should contain an `optimize-secret` field, which will be used as secret for the identity-Optimize communication.
        existingSecret:
        ## @param global.identity.auth.optimize.redirectUrl defines the root (or redirect) URL, which is used by Keycloak to access Optimize.
        # Should be publicly accessible, the default value works if a port-forward to Optimize is created to 8083.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8083"

      ## @extra global.identity.auth.webModeler configuration to configure Web Modeler authentication specifics on global level, which can be accessed by other sub-charts
      webModeler:
        ## @param global.identity.auth.webModeler.clientId defines the client id, which is used by Web Modeler in authentication flows.
        clientId: web-modeler
        ## @param global.identity.auth.webModeler.clientApiAudience defines the audience which is used by Web Modeler's client API.
        clientApiAudience: web-modeler-api
        ## @param global.identity.auth.webModeler.publicApiAudience defines the audience which is used by Web Modeler's public API.
        publicApiAudience: web-modeler-public-api
        ## @param global.identity.auth.webModeler.redirectUrl defines the root URL which is used by Keycloak to access Web Modeler.
        # Should be publicly accessible, the default value works if a port-forward to Web Modeler is created to 8084.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8084"

      ## global.identity.auth.console configuration to configure Console authentication specifics on global level, which can be accessed by other sub-charts
      console:
        ## @skip global.identity.auth.console.existingSecret can be used to use an own existing secret. If not set a random secret is generated.
        # The existing secret should contain an `console-secret` field, which will be used as secret for the identity-console communication.
        existingSecret:
        ## @skip global.identity.auth.console.redirectUrl defines the root URL which is used by Keycloak to access Web Modeler.
        # Should be publicly accessible, the default value works if a port-forward to Web Modeler is created to 8080.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8080"

      ## @extra global.identity.auth.zeebe configuration to configure Zeebe authentication specifics on global level, which can be accessed by other sub-charts
      zeebe:
        ## @param global.identity.auth.zeebe.clientId defines the client id, which is used by Zeebe in authentication flows.
        clientId: zeebe
        ## @param global.identity.auth.zeebe.existingSecret can be used to use an own existing secret. If not set a random secret is generated.
        # The existing secret should contain an `zeebe-secret` field, which will be used as secret for the Identity-Zeebe communication.
        existingSecret: ""
        ## @param global.identity.auth.zeebe.audience defines the audience, which is used by Zeebe.
        audience: zeebe-api
        ## @param global.identity.auth.zeebe.tokenScope defines the token scope, which is used by Zeebe.
        tokenScope:

  multiregion:
    regions: 1
    regionId: 0
    installationType: normal

## @section Zeebe Parameters
## @extra zeebe configuration for the Zeebe sub chart. Contains configuration for the Zeebe broker and related resources.
zeebe:
  ## @param zeebe.enabled if true, all zeebe related resources are deployed via the helm release
  enabled: true

  ## @param zeebe.debug if true, extra info is printed.
  debug: false

  ## @extra zeebe.image configuration to configure the zeebe image specifics
  image:
     ## @param zeebe.image.registry can be used to set container image registry.
    registry: ""
     ## @param zeebe.image.repository defines which image repository to use
    repository: camunda/zeebe
     ## @param zeebe.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag:
     ## @param zeebe.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @param zeebe.sidecars can be used to attach extra containers to the zeebe deployment
  sidecars: []

  ## @param zeebe.clusterSize defines the amount of brokers (=replicas), which are deployed via helm
  clusterSize: "3"
  ## @param zeebe.partitionCount defines how many zeebe partitions are set up in the cluster
  partitionCount: "3"
  ## @param zeebe.replicationFactor defines how each partition is replicated, the value defines the number of nodes
  replicationFactor: "3"
  ## @extra zeebe.env can be used to set extra environment variables in each zeebe broker container
  env:
    ## @param zeebe.env[0].name
    ## @param zeebe.env[0].value
    ## @param zeebe.env[1].name
    ## @param zeebe.env[1].value
    ## @param zeebe.env[2].name
    ## @param zeebe.env[2].value
    - name: ZEEBE_BROKER_DATA_SNAPSHOTPERIOD
      value: "5m"
    - name: ZEEBE_BROKER_DATA_DISK_FREESPACE_REPLICATION
      value: "2GB"
    - name: ZEEBE_BROKER_DATA_DISK_FREESPACE_PROCESSING
      value: "3GB"
  ## @extra zeebe.configMap configuration which will be applied to the mounted config map.
  configMap:
     ## @param zeebe.configMap.defaultMode can be used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. see https://github.com/kubernetes/api/blob/master/core/v1/types.go#L1615-L1623
    defaultMode: 0754
  ## @param zeebe.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []

  ## @param zeebe.logLevel defines the log level which is used by the zeebe brokers
  logLevel: info
  ## @param zeebe.log4j2 can be used to overwrite the log4j2 configuration of the zeebe brokers
  log4j2: ''
  ## @param zeebe.javaOpts can be used to set java options for the zeebe brokers
  javaOpts: >-
    -XX:+HeapDumpOnOutOfMemoryError
    -XX:HeapDumpPath=/usr/local/zeebe/data
    -XX:ErrorFile=/usr/local/zeebe/data/zeebe_error%p.log
    -XX:+ExitOnOutOfMemoryError

  ## @extra zeebe.service configuration for the broker service
  service:
     ## @param zeebe.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
     ## @param zeebe.service.httpPort defines the port of the http endpoint, where for example metrics are provided
    httpPort: 9600
     ## @param zeebe.service.httpName defines the name of the http endpoint, where for example metrics are provided
    httpName: "http"
     ## @param zeebe.service.commandPort defines the port of the command api endpoint, where the broker commands are sent to
    commandPort: 26501
     ## @param zeebe.service.commandName defines the name of the command api endpoint, where the broker commands are sent to
    commandName: "command"
     ## @param zeebe.service.internalPort defines the port of the internal api endpoint, which is used for internal communication
    internalPort: 26502
     ## @param zeebe.service.internalName defines the name of the internal api endpoint, which is used for internal communication
    internalName: "internal"
     ## @param zeebe.service.extraPorts can be used to expose any other ports which are required. Can be useful for exporters
    extraPorts: []
      # - name: hazelcast
      #   protocol: TCP
      #   port: 5701
      #   targetPort: 5701

  ## @extra global.zeebe.ServiceAccount configuration for the service account where the broker pods are assigned to
  serviceAccount:
     ## @param zeebe.serviceAccount.enabled if true, enables the broker service account
    enabled: true
     ## @param zeebe.serviceAccount.name can be used to set the name of the broker service account
    name: ""
     ## @param zeebe.serviceAccount.annotations can be used to set the annotations of the broker service account
    annotations: {}

  ## @param zeebe.cpuThreadCount defines how many threads can be used for the processing on each broker pod
  cpuThreadCount: "3"
  ## @param zeebe.ioThreadCount defines how many threads can be used for the exporting on each broker pod
  ioThreadCount: "3"
  ## @extra zeebe.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @extra zeebe.resources.requests
  ## @param zeebe.resources.requests.cpu
  ## @param zeebe.resources.requests.memory
  ## @param zeebe.resources.limits.cpu
  ## @param zeebe.resources.limits.memory
  resources:
    requests:
      cpu: 800m
      memory: 1200Mi
    limits:
      cpu: 960m
      memory: 1920Mi

  ## @param zeebe.persistenceType defines the type of persistence which is used by Zeebe. Possible values are: disk, local and memory.
  #   disk  - means a persistence volume claim is configured and used
  #   local - means the data is stored into the container, no volumeMount nor volume nor claim is configured
  #   memory   - means zeebe uses a tmpfs for the data persistence, be aware that this takes the limits into account
  persistenceType: disk
  ## @param zeebe.pvcSize defines the persistent volume claim size, which is used by each broker pod https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims
  pvcSize: "32Gi"
  ## @param zeebe.pvcAccessModes can be used to configure the persistent volume claim access mode https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
  pvcAccessModes: ["ReadWriteOnce"]
  ## @param zeebe.pvcStorageClassName can be used to set the storage class name which should be used by the persistent volume claim. It is recommended to use a storage class, which is backed with a SSD.
  pvcStorageClassName: ''

  ## @param zeebe.extraVolumes can be used to define extra volumes for the broker pods, useful for additional exporters
  extraVolumes: []
  ## @param zeebe.extraVolumeMounts can be used to mount extra volumes for the broker pods, useful for additional exporters
  extraVolumeMounts: []
  ## @param zeebe.extraInitContainers (Deprecated - use `initContainers` instead) ExtraInitContainers can be used to set up extra init containers for the broker pods, useful for additional exporters
  extraInitContainers: []
  ## @param zeebe.initContainers can be used to set up extra init containers for the broker pods, useful for additional exporters
  initContainers: []

  ## @param zeebe.podAnnotations can be used to define extra broker pod annotations
  podAnnotations: {}
  ## @param zeebe.podLabels can be used to define extra broker pod labels
  podLabels: {}
  ## @extra zeebe.podDisruptionBudget configuration to configure a pod disruption budget for the broker pods https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget:
     ## @param zeebe.podDisruptionBudget.enabled if true a pod disruption budget is defined for the brokers
    enabled: false
     ## @param zeebe.podDisruptionBudget.minAvailable can be used to set how many pods should be available. Be aware that if minAvailable is set, maxUnavailable will not be set (they are mutually exclusive).
    minAvailable:
     ## @param zeebe.podDisruptionBudget.maxUnavailable can be used to set how many pods should be at max. unavailable
    maxUnavailable: 1

  ## @extra zeebe.podSecurityContext defines the security options the Zeebe broker pod should be run with
  podSecurityContext:
    ## @param zeebe.podSecurityContext.runAsNonRoot run as non root
    runAsNonRoot: true
    ## @param zeebe.podSecurityContext.fsGroup
    fsGroup: 1000

  # ContainerSecurityContext defines the security options the Zeebe broker container should be run with
  containerSecurityContext:
    ## @param zeebe.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param zeebe.containerSecurityContext.privileged
    privileged: false
    ## @param zeebe.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param zeebe.containerSecurityContext.runAsUser
    runAsUser: 1000

  ## @extra zeebe.startupProbe configuration
  startupProbe:
     ## @param zeebe.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
     ## @param zeebe.startupProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
     ## @param zeebe.startupProbe.probePath defines the startup probe route used on the app
    probePath: /ready
     ## @param zeebe.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
     ## @param zeebe.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
     ## @param zeebe.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
     ## @param zeebe.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
     ## @param zeebe.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra zeebe.readinessProbe configuration
  readinessProbe:
     ## @param zeebe.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
     ## @param zeebe.readinessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
     ## @param zeebe.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /ready
     ## @param zeebe.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
     ## @param zeebe.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
     ## @param zeebe.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
     ## @param zeebe.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
     ## @param zeebe.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra zeebe.livenessProbe configuration
  livenessProbe:
     ## @param zeebe.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
     ## @param zeebe.livenessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
     ## @param zeebe.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /health
     ## @param zeebe.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
     ## @param zeebe.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
     ## @param zeebe.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
     ## @param zeebe.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
     ## @param zeebe.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @param zeebe.nodeSelector can be used to define on which nodes the broker pods should run
  nodeSelector: {}
  ## @param zeebe.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @extra global.zeebe.Affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  # The default defined PodAntiAffinity allows constraining on which nodes the Zeebe pods are scheduled on https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  # It uses a hard requirement for scheduling and works based on the Zeebe pod labels
  ## @skip zeebe.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].labelSelector.matchExpressions[0].key
  ## @skip zeebe.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].labelSelector.matchExpressions[0].operator
  ## @skip zeebe.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].labelSelector.matchExpressions[0].values
  ## @skip zeebe.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].topologyKey
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
              - key: "app.kubernetes.io/component"
                operator: In
                values:
                  - zeebe-broker
          topologyKey: "kubernetes.io/hostname"

  ## @param zeebe.priorityClassName can be used to define the broker pods priority https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
  priorityClassName: ""

  retention:
    ## @param zeebe.retention.enabled if true, the ILM Policy is created and applied to the index templates.
    enabled: false
    ## @param zeebe.retention.minimumAge defines how old the data must be, before the data is deleted as a duration.
    minimumAge: 30d
    ## @param zeebe.retention.policyName defines the name of the created and applied ILM policy.
    policyName: zeebe-record-retention-policy

## @section Zeebe Gateway Parameters
## @extra Gateway configuration to define properties related to the standalone gateway
zeebe-gateway:
  replicas: 2
  logLevel: info
  javaOpts: >-
    -XX:+ExitOnOutOfMemoryError

  ## @param zeebe-gateway.env can be used to set extra environment variables in each gateway container
  env: []
  ## @extra zeebe-gateway.configMap configuration which will be applied to the mounted config map.
  configMap:
    ## @param zeebe-gateway.configMap.defaultMode can be used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    # See https://github.com/kubernetes/api/blob/master/core/v1/types.go#L1615-L1623
    defaultMode: 0744

  ## @extra zeebe-gateway.serviceAccount configuration for the service account where the gateway pods are assigned to
  serviceAccount:
    ## @param zeebe-gateway.serviceAccount.enabled if true, enables the gateway service account
    enabled: true
    ## @param zeebe-gateway.serviceAccount.name can be used to set the name of the gateway service account
    name: ""
    ## @param zeebe-gateway.serviceAccount.annotations can be used to set the annotations of the gateway service account
    annotations: {}

  ingress:
    enabled: true
    className: nginx
    annotations:
      ingress.kubernetes.io/rewrite-target: "/"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
      nginx.ingress.kubernetes.io/backend-protocol: "GRPC"
      nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
      cert-manager.io/cluster-issuer: le-linshare-dev
      kubernetes.io/tls-acme: "true"
    path: /
    host: gateway.camunda.integration-linshare.org
    tls:
      enabled: true
      secretName: camunda-platform-zeebe-gateway

## @section Operate Parameters
## @extra.operate configuration for the Operate sub chart.
operate:
  ## @param operate.enabled if true, the Operate deployment and its related resources are deployed via a helm release
  enabled: true
  resources:
    requests:
      cpu: 600m
      memory: 400Mi
    limits:
      cpu: 2000m
      memory: 2Gi

  ingress:
    enabled: true
    className: nginx
    annotations:
      ingress.kubernetes.io/rewrite-target: "/"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
      nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
      cert-manager.io/cluster-issuer: le-linshare-dev
      kubernetes.io/tls-acme: "true"
    path: /
    host: operate.camunda.integration-linshare.org
    tls:
      enabled: true
      ## @param operate.ingress.tls.secretName defines the secret name which contains the TLS private key and certificate
      secretName: camunda-platform-operate

## @section Tasklist Parameters
# Tasklist configuration for the tasklist sub chart.
tasklist:
  ## @param tasklist.enabled if true, the tasklist deployment and its related resources are deployed via a helm release
  enabled: true

  ## @extra tasklist.image configuration to configure the tasklist image specifics
  image:
    ## @param tasklist.image.registry can be used to set container image registry.
    registry: ""
    ## @param tasklist.image.repository defines which image repository to use
    repository: camunda/tasklist
    ## @param tasklist.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag:
    ## @param tasklist.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @param tasklist.sidecars can be used to attach extra containers to the tasklist deployment
  sidecars: []
  ## @param tasklist.initContainers can be used to set up extra init containers for the taskList pods, useful for additional exporters
  initContainers: []
  # contextPath: "/tasklist"
  ## @param tasklist.contextPath can be used to make Tasklist web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @param tasklist.env can be used to set extra environment variables on each Tasklist container
  env: []

  ## @param tasklist.podAnnotations can be used to define extra Tasklist pod annotations
  podAnnotations: {}
  ## @param tasklist.podLabels can be used to define extra tasklist pod labels
  podLabels: {}

  ## @extra tasklist.configMap configuration which will be applied to the mounted config map.
  configMap:
    ## @param tasklist.configMap.defaultMode can be used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    # See https://github.com/kubernetes/api/blob/master/core/v1/types.go#L1615-L1623
    defaultMode: 0744
  ## @param tasklist.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @extra tasklist.service configuration to configure the tasklist service.
  service:
    ## @param tasklist.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param tasklist.service.port defines the port of the service, where the tasklist web application will be available
    port: 80

  ## @extra tasklist.identity configures app user management.
  identity:
    userAccessRestrictions:
      ## @param tasklist.identity.userAccessRestrictions.enabled if true, enables the identity user access restrictions
      enabled: true

  ## @param tasklist.extraVolumes can be used to define extra volumes for the Tasklist pods, useful for tls and self-signed certificates
  extraVolumes: []
  ## @param tasklist.extraVolumeMounts can be used to mount extra volumes for the Tasklist pods, useful for tls and self-signed certificates
  extraVolumeMounts: []

  ## @extra tasklist.serviceAccount configuration for the service account where the Tasklist pods are assigned to
  serviceAccount:
    ## @param tasklist.serviceAccount.enabled if true, enables the Tasklist service account
    enabled: true
    ## @param tasklist.serviceAccount.name can be used to set the name of the Tasklist service account
    name: ""
    ## @param tasklist.serviceAccount.annotations can be used to set the annotations of the Tasklist service account
    annotations: {}

  ## @extra tasklist.podSecurityContext defines the security options the Tasklist pod should be run with
  podSecurityContext:
  ## @param tasklist.podSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param tasklist.podSecurityContext.fsGroup
    fsGroup: 1002

  ## @extra tasklist.containerSecurityContext defines the security options the Tasklist container should be run with
  containerSecurityContext:
  ## @param tasklist.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param tasklist.containerSecurityContext.privileged
    privileged: false
    ## @param tasklist.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param tasklist.containerSecurityContext.runAsUser
    runAsUser: 1002

  ## @extra tasklist.startupProbe configuration
  startupProbe:
    ## @param tasklist.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param tasklist.startupProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param tasklist.startupProbe.probePath defines the startup probe route used on the app
    probePath: /actuator/health/readiness
    ## @param tasklist.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param tasklist.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param tasklist.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param tasklist.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param tasklist.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra tasklist.readinessProbe configuration
  readinessProbe:
    ## @param tasklist.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param tasklist.readinessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param tasklist.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /actuator/health/readiness
    ## @param tasklist.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param tasklist.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param tasklist.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param tasklist.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param tasklist.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra tasklist.livenessProbe configuration
  livenessProbe:
    ## @param tasklist.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param tasklist.livenessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param tasklist.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /actuator/health/liveness
    ## @param tasklist.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param tasklist.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param tasklist.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param tasklist.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param tasklist.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @param tasklist.nodeSelector can be used to define on which nodes the Tasklist pods should run
  nodeSelector: {}
  ## @param tasklist.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param tasklist.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  ## @extra tasklist.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param tasklist.resources.requests.cpu
  ## @param tasklist.resources.requests.memory
  ## @param tasklist.resources.limits.cpu
  ## @param tasklist.resources.limits.memory
  resources:
    requests:
      cpu: 400m
      memory: 1Gi
    limits:
      cpu: 1000m
      memory: 2Gi

  ingress:
    enabled: true
    className: nginx
    annotations:
      ingress.kubernetes.io/rewrite-target: "/"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
      nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
      cert-manager.io/cluster-issuer: le-linshare-dev
      kubernetes.io/tls-acme: "true"
    path: /
    host: tasklist.camunda.integration-linshare.org
    tls:
      enabled: true
      secretName: camunda-platform-tasklist

  # Retention can be used to define the data in Elasticsearch (ILM).
  retention:
    ## @param tasklist.retention.enabled if true, the ILM Policy is created and applied to the index templates.
    enabled: false
    ## @param tasklist.retention.minimumAge defines how old the data must be, before the data is deleted as a duration.
    minimumAge: 30d

## @section Optimize Parameters
# Optimize configuration for the Optimize sub chart.
optimize:
  ## @param optimize.enabled if true, the Optimize deployment and its related resources are deployed via a helm release
  enabled: true
  resources:
    requests:
      cpu: 600m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 2Gi

  ingress:
    ## @param optimize.ingress.enabled if true, an ingress resource is deployed with the Optimize deployment. Only useful if an ingress controller is available, like nginx.
    enabled: false
    ## @param optimize.ingress.className defines the class or configuration of ingress which should be used by the controller
    className: nginx
    ## @param optimize.ingress.annotations [object] defines the ingress related annotations, consumed mostly by the ingress controller
    ## @skip optimize.ingress.annotations.ingress.kubernetes.io/rewrite-target
    ## @skip optimize.ingress.annotations.nginx.ingress.kubernetes.io/ssl-redirect
    ## @skip optimize.ingress.annotations.nginx.ingress.kubernetes.io/proxy-buffer-size
    annotations:
      ingress.kubernetes.io/rewrite-target: "/"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
      nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
    ## @param optimize.ingress.path defines the path which is associated with the operate service and port https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    path: /
    ## @param optimize.ingress.host can be used to define the host of the ingress rule. https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    # If not specified the rules applies to all inbound http traffic, if specified the rule applies to that host.
    host: ""
    ## @extra optimize.ingress.tls configuration for tls on the ingress resource https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    tls:
      ## @param optimize.ingress.tls.enabled if true, then tls is configured on the ingress resource. If enabled the Ingress.host need to be defined.
      enabled: false
      ## @param optimize.ingress.tls.secretName defines the secret name which contains the TLS private key and certificate
      secretName: camunda-platform-optimize


## @section Identity Parameters
# Identity configuration for the identity sub chart.
identity:
  ## @param identity.enabled if true, the identity deployment and its related resources are deployed via a helm release
  #
  # Note: If using Keycloak, Identity is required by Optimize and Web Modeler.
  #       If you need neither Optimize nor Web Modeler, make sure to disable both the Identity authentication and the applications by setting:
  #         global.identity.auth.enabled=false
  #         optimize.enabled=false
  #         webModeler.enabled=false
  enabled: true

  ## @param identity.fullnameOverride can be used to override the full name of the Identity resources
  fullnameOverride: ""
  ## @param identity.nameOverride can be used to partly override the name of the Identity resources (names will still be prefixed with the release name)
  nameOverride: ""

  ## @extra identity.firstUser configuration to configure properties of the first Identity user, which can be used to access all
  # web applications
  firstUser:
    ## @param identity.firstUser.enabled if true, Identity will seed the first user in Keycloak.
    enabled: true
    ## @param identity.firstUser.username defines the username of the first user, needed to log in into the web applications
    username: demo
    ## @param identity.firstUser.password defines the password of the first user, needed to log in into the web applications
    password: demo
    ## @param identity.firstUser.email defines the email address of the first user; a valid email address is required to use Web Modeler
    email: demo@example.org
    ## @param identity.firstUser.firstName defines the first name of the first user; a name is required to use Web Modeler
    firstName: Demo
    ## @param identity.firstUser.lastName defines the last name of the first user; a name is required to use Web Modeler
    lastName: User
    ## @param identity.firstUser.existingSecret can be used to use an own existing secret for Identity first user.
    # Currently, only password field is supported via "identity-firstuser-password" key in the secret resource.
    existingSecret: ""

  ## @extra identity.image configuration to configure the identity image specifics
  image:
    ## @param identity.image.registry can be used to set container image registry.
    registry: ""
    ## @param identity.image.repository defines which image repository to use
    repository: camunda/identity
    ## @param identity.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag:
    ## @param identity.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @param identity.sidecars can be used to attach extra containers to the identity deployment
  sidecars: []
  ## @param identity.initContainers can be used to set up extra init containers for the identity pods, useful for additional exporters
  initContainers: []
  # FullURL can be used when Ingress is configured (for both multi and single domain setup).
  # Note: If the `ContextPath` is configured, then value of `ContextPath` should be included in the URL too.
  # fullURL: "https://camunda.example.com/identity"

  # Note: Identity cannot be accessed over HTTP if a "contextPath" is configured.
  #       Which means that Identity cannot be configured in combined Ingress without HTTPS.
  #       To use Identity over HTTP, setup a separated Ingress using "identity.ingress" and don't set "contextPath".
  # contextPath: "/identity"
  ## @param identity.contextPath can be used to make Identity web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @param identity.podAnnotations can be used to define extra Identity pod annotations
  podAnnotations: {}
  ## @param identity.podLabels can be used to define extra Identity pod labels
  podLabels: {}

  ## @extra identity.service configuration to configure the identity service.
  service:
    ## @param identity.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param identity.service.annotations can be used to define annotations, which will be applied to the identity service
    annotations: {}
    ## @param identity.service.port defines the port of the service on which the identity application will be available
    port: 80
    ## @param identity.service.metricsPort defines the port of the service on which the identity metrics will be available
    metricsPort: 82
    ## @param identity.service.metricsName defines the name of the service on which the identity metrics will be available
    metricsName: metrics

 ## @extra identity.podSecurityContext defines the security options the Identity pod should be run with
  podSecurityContext:
  ## @param identity.podSecurityContext.fsGroup
    fsGroup: 1005

  ## @extra identity.containerSecurityContext defines the security options the Identity container should be run with
  containerSecurityContext:
  ## @param identity.containerSecurityContext.privileged
    privileged: false
    ## @param identity.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param identity.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param identity.containerSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param identity.containerSecurityContext.runAsUser
    runAsUser: 1005

  ## @extra identity.startupProbe configuration
  startupProbe:
    ## @param identity.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param identity.startupProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param identity.startupProbe.probePath defines the startup probe route used on the app
    probePath: /actuator/health
    ## @param identity.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param identity.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param identity.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param identity.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param identity.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra identity.readinessProbe configuration
  readinessProbe:
    ## @param identity.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param identity.readinessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param identity.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /actuator/health
    ## @param identity.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param identity.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param identity.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param identity.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param identity.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra identity.livenessProbe configuration
  livenessProbe:
    ## @param identity.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param identity.livenessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param identity.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /actuator/health
    ## @param identity.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param identity.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param identity.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param identity.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param identity.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @param identity.nodeSelector can be used to define on which nodes the Identity pods should run
  nodeSelector: {}
  ## @param identity.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param identity.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  ## @extra identity.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param identity.resources.requests.memory
  ## @param identity.resources.limits.cpu
  ## @param identity.resources.requests.cpu
  ## @param identity.resources.limits.memory
  resources:
    requests:
      cpu: 600m
      memory: 400Mi
    limits:
      cpu: 2000m
      memory: 2Gi

  ## @param identity.env can be used to set extra environment variables in each identity container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
  env: []
  ## @param identity.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @param identity.extraVolumes can be used to define extra volumes for the identity pods, useful for tls and self-signed certificates
  extraVolumes: []
  ## @param identity.extraVolumeMounts can be used to mount extra volumes for the identity pods, useful for tls and self-signed certificates
  extraVolumeMounts: []

  ## @extra identity.serviceAccount configuration for the service account where the identity pods are assigned to
  serviceAccount:
    ## @param identity.serviceAccount.enabled if true, enables the identity service account
    enabled: true
    ## @param identity.serviceAccount.name can be used to set the name of the identity service account
    name: ""
    ## @param identity.serviceAccount.annotations can be used to set the annotations of the identity service account
    annotations: {}

  ingress:
    enabled: true
    className: nginx
    annotations:
      ingress.kubernetes.io/rewrite-target: "/"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
      nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
      cert-manager.io/cluster-issuer: le-linshare-dev
      kubernetes.io/tls-acme: "true"
    path: /
    host: identity.camunda.integration-linshare.org
    tls:
      enabled: true
      secretName: camunda-platform-identity

  ## PostgreSQL chart configuration
  postgresql:
    ## @param identity.postgresql.enabled Enable PostgreSQL Helm chart. Required for Multi-Tenancy.
    enabled: false

  ## External PostgreSQL configuration. Required for Multi-Tenancy.
  ## All of these values are only used when postgresql.enabled is set to false
  externalDatabase:
    enabled: false

  # Identity.keycloak
  ## @extra identity.keycloak configuration, for the keycloak dependency chart which is used by identity.
  # For more details: https://github.com/bitnami/charts/tree/master/bitnami/keycloak#parameters
  keycloak:
    ## @extra identity.keycloak.postgresql configuration.
    postgresql:
      # https://hub.docker.com/r/bitnami/postgresql/tags
      image:
        ## @param identity.keycloak.postgresql.image.repository image repo
        repository: bitnami/postgresql
        ## @param identity.keycloak.postgresql.image.tag image tag
        tag: 15.5.0
      primary:
        ## @skip identity.keycloak.postgresql.primary.extraVolumes[0].name
        ## @skip identity.keycloak.postgresql.primary.extraVolumes[0].emptyDir
        ## @skip identity.keycloak.postgresql.primary.extraVolumes[1].name
        ## @skip identity.keycloak.postgresql.primary.extraVolumes[1].emptyDir
        ## @skip identity.keycloak.postgresql.primary.extraVolumes[2].name
        ## @skip identity.keycloak.postgresql.primary.extraVolumes[2].emptyDir
        extraVolumes:
        - name: tmp
          emptyDir: {}
        - name: config
          emptyDir: {}
        - name: postgresql-tmp
          emptyDir: {}
        ## identity.keycloak.postgresql.primary.extraVolumeMounts can be used to mount extra volumes for the identity pods, useful for tls and self-signed certificates
        ## @skip identity.keycloak.postgresql.primary.extraVolumeMounts[0].mountPath
        ## @skip identity.keycloak.postgresql.primary.extraVolumeMounts[0].name
        ## @skip identity.keycloak.postgresql.primary.extraVolumeMounts[1].mountPath
        ## @skip identity.keycloak.postgresql.primary.extraVolumeMounts[1].name
        ## @skip identity.keycloak.postgresql.primary.extraVolumeMounts[2].mountPath
        ## @skip identity.keycloak.postgresql.primary.extraVolumeMounts[2].name
        extraVolumeMounts:
        - mountPath: /tmp
          name: tmp
        - mountPath: /opt/bitnami/postgresql/conf
          name: config
        - mountPath: /opt/bitnami/postgresql/tmp
          name: postgresql-tmp
        ## @param identity.keycloak.postgresql.primary.containerSecurityContext.enabled
        ## @param identity.keycloak.postgresql.primary.containerSecurityContext.privileged
        ## @param identity.keycloak.postgresql.primary.containerSecurityContext.readOnlyRootFilesystem
        ## @param identity.keycloak.postgresql.primary.containerSecurityContext.allowPrivilegeEscalation
        ## @param identity.keycloak.postgresql.primary.containerSecurityContext.runAsNonRoot
        ## @param identity.keycloak.postgresql.primary.containerSecurityContext.runAsUser
        ## @param identity.keycloak.postgresql.primary.containerSecurityContext.capabilities.drop
        ## @param identity.keycloak.postgresql.primary.containerSecurityContext.seccompProfile.type
        containerSecurityContext:
          enabled: true
          privileged: false
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          runAsNonRoot: true
          runAsUser: 1001
          capabilities:
            drop: ["ALL"]
          seccompProfile:
            type: RuntimeDefault
        ## @param identity.keycloak.postgresql.primary.podSecurityContext.enabled
        ## @param identity.keycloak.postgresql.primary.podSecurityContext.runAsNonRoot
        ## @param identity.keycloak.postgresql.primary.podSecurityContext.fsGroup
        podSecurityContext:
          enabled: true
          runAsNonRoot: true
          fsGroup: 1001

    ## @param identity.keycloak.enabled is used incorporate with "global.identity.keycloak" to use your own Keycloak instead of the one comes with Camunda Helm chart
    enabled: true

    ## @extra identity.keycloak.image configuration.
    # https://hub.docker.com/r/bitnami/keycloak/tags
    image:
      ## @param identity.keycloak.image.repository image repo
      repository: bitnami/keycloak
      ## @param identity.keycloak.image.tag image tag
      tag: 22.0.5

    # Keycloak.proxy defines the proxy mode depends on the TLS termination in your environment.
    # Docs: https://www.keycloak.org/server/reverseproxy
    ## @param identity.keycloak.proxy keycloak proxy
    proxy: edge

    ## @extra identity.keycloak.tls can be used to enable TLS encryption. Required for HTTPs traffic.
    tls:
    ## @param identity.keycloak.tls.enabled enabling tls
      enabled: false

    # NOTE: Since Helm v3 (latest checked 3.10.x) doesn't merge lists with custom values files, then you will need to
    # add this to your own values file if you override any of "extraVolumes", "initContainers", or "extraVolumeMounts".
    ## @skip identity.keycloak.extraVolumes [object] Extra volumes for keycloak
    ## @skip identity.keycloak.extraVolumes[0].name
    ## @skip identity.keycloak.extraVolumes[0].emptyDir
    ## @skip identity.keycloak.extraVolumes[1].name
    ## @skip identity.keycloak.extraVolumes[1].emptyDir
    ## @skip identity.keycloak.extraVolumes[2].name
    ## @skip identity.keycloak.extraVolumes[2].emptyDir
    ## @skip identity.keycloak.extraVolumes[3].name
    ## @skip identity.keycloak.extraVolumes[3].emptyDir.sizeLimit
    ## @skip identity.keycloak.extraVolumes[4].name
    ## @skip identity.keycloak.extraVolumes[4].emptyDir.sizeLimit
    extraVolumes:
    - name: config
      emptyDir: {}
    - name: quarkus
      emptyDir: {}
    - name: tmp
      emptyDir: {}
    - name: data-tmp
      emptyDir: {}
    - name: camunda-theme
      emptyDir:
        sizeLimit: 10Mi

    initContainers:
    ## @param identity.keycloak.initContainers[0].name
    ## @param identity.keycloak.initContainers[0].image
    ## @param identity.keycloak.initContainers[0].imagePullPolicy
    ## @param identity.keycloak.initContainers[0].command
    ## @param identity.keycloak.initContainers[0].securityContext.privileged
    ## @param identity.keycloak.initContainers[0].securityContext.readOnlyRootFilesystem
    ## @param identity.keycloak.initContainers[0].securityContext.allowPrivilegeEscalation
    ## @param identity.keycloak.initContainers[0].securityContext.runAsNonRoot
    ## @param identity.keycloak.initContainers[0].securityContext.runAsUser
    ## @param identity.keycloak.initContainers[0].securityContext.capabilities.drop
    ## @param identity.keycloak.initContainers[0].securityContext.seccompProfile.type
    ## @param identity.keycloak.initContainers[0].volumeMounts[0].name
    ## @param identity.keycloak.initContainers[0].volumeMounts[0].mountPath
    - name: copy-camunda-theme
      image: >-
        {{- $identityImageParams := (dict "base" .Values.global "overlay" .Values.global.identity) -}}
        {{- include "camundaPlatform.imageByParams" $identityImageParams }}
      imagePullPolicy: "{{ .Values.global.image.pullPolicy }}"
      command: ["sh", "-c", "cp -a /app/keycloak-theme/* /mnt"]
      securityContext:
        privileged: false
        readOnlyRootFilesystem: true
        allowPrivilegeEscalation: false
        runAsNonRoot: true
        # START DEV COMMENT
        # TODO: Remove the runAsUser when the numeric ID is used in the Identity Docker image.
        # END DEV COMMENT
        runAsUser: 1005
        capabilities:
          drop: ["ALL"]
        seccompProfile:
          type: RuntimeDefault
      volumeMounts:
      - name: camunda-theme
        mountPath: /mnt
    ## @param identity.keycloak.initContainers[1].name
    ## @param identity.keycloak.initContainers[1].image
    ## @param identity.keycloak.initContainers[1].imagePullPolicy
    ## @param identity.keycloak.initContainers[1].command
    ## @param identity.keycloak.initContainers[1].securityContext.privileged
    ## @param identity.keycloak.initContainers[1].securityContext.readOnlyRootFilesystem
    ## @param identity.keycloak.initContainers[1].securityContext.allowPrivilegeEscalation
    ## @param identity.keycloak.initContainers[1].securityContext.runAsNonRoot
    ## @param identity.keycloak.initContainers[1].securityContext.capabilities.drop
    ## @param identity.keycloak.initContainers[1].securityContext.seccompProfile.type
    ## @param identity.keycloak.initContainers[1].volumeMounts[0].name
    ## @param identity.keycloak.initContainers[1].volumeMounts[0].mountPath
    ## @param identity.keycloak.initContainers[1].volumeMounts[1].name
    ## @param identity.keycloak.initContainers[1].volumeMounts[1].mountPath
    - name: copy-configs
      image: "{{ .Values.image.registry }}/{{ .Values.image.repository }}:{{ .Values.image.tag }}"
      imagePullPolicy: "Always"
      command: ["sh", "-c", "cp -ar /opt/bitnami/keycloak/conf/* /config && cp -a /opt/bitnami/keycloak/lib/quarkus/* /quarkus"]
      securityContext:
        privileged: false
        readOnlyRootFilesystem: true
        allowPrivilegeEscalation: false
        runAsNonRoot: true
        capabilities:
          drop: ["ALL"]
        seccompProfile:
          type: RuntimeDefault
      volumeMounts:
      - name: config
        mountPath: /config
      - name: quarkus
        mountPath: /quarkus
    ## @param identity.keycloak.extraVolumeMounts[0].name
    ## @param identity.keycloak.extraVolumeMounts[0].mountPath
    ## @param identity.keycloak.extraVolumeMounts[1].mountPath
    ## @param identity.keycloak.extraVolumeMounts[1].name
    ## @param identity.keycloak.extraVolumeMounts[2].name
    ## @param identity.keycloak.extraVolumeMounts[2].mountPath
    ## @param identity.keycloak.extraVolumeMounts[3].mountPath
    ## @param identity.keycloak.extraVolumeMounts[3].name
    ## @param identity.keycloak.extraVolumeMounts[4].mountPath
    ## @param identity.keycloak.extraVolumeMounts[4].name
    extraVolumeMounts:
    - mountPath: /opt/bitnami/keycloak/conf/
      name: config
    - mountPath: /opt/bitnami/keycloak/lib/quarkus
      name: quarkus
    - name: camunda-theme
      mountPath: /opt/bitnami/keycloak/themes/identity
    - mountPath: /tmp
      name: tmp
    - mountPath: /opt/bitnami/keycloak/data/tmp
      name: data-tmp

    ## @param identity.keycloak.containerSecurityContext.privileged
    ## @param identity.keycloak.containerSecurityContext.readOnlyRootFilesystem
    ## @param identity.keycloak.containerSecurityContext.allowPrivilegeEscalation
    ## @param identity.keycloak.containerSecurityContext.runAsNonRoot
    ## @param identity.keycloak.containerSecurityContext.runAsUser
    ## @param identity.keycloak.containerSecurityContext.capabilities.drop
    ## @param identity.keycloak.containerSecurityContext.seccompProfile.type
    containerSecurityContext:
      privileged: false
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
      runAsNonRoot: true
      runAsUser: 1001
      capabilities:
        drop: ["ALL"]
      seccompProfile:
        type: RuntimeDefault
    ## @param identity.keycloak.podSecurityContext.fsGroup
    podSecurityContext:
      fsGroup: 1001
    ## @param identity.keycloak.httpRelativePath defines the context for Keycloak. This config is valid for Keycloak v19.x.x only
    # where in Keycloak v16.x.x it's hard-coded as '/auth', but in v19.x.x it's configurable.
    # NOTE: This should be the same as ".Values.global.identity.keycloak.contextPath" plus a trailing slash,
    # but it cannot be referenced directly because of a bug in Helm (tested with Helm v3.9.3).
    httpRelativePath: /auth/
    ## @extra identity.extraEnvVars
    ## @param identity.keycloak.extraEnvVars[0].name
    ## @param identity.keycloak.extraEnvVars[0].value
    extraEnvVars:
    # KEYCLOAK_PROXY_ADDRESS_FORWARDING can be used with Ingress that has SSL Termination. It will be "true" if the TLS
    # in global Ingress is enabled, but it could be overwritten with separate Ingress setup.
    - name: KEYCLOAK_PROXY_ADDRESS_FORWARDING
      value: "{{ .Values.global.ingress.tls.enabled }}"

    # under "global.ingress" is enabled. However, it's possible to setup Keycloak on a separate Ingress if needed.
    # For more details: https://github.com/bitnami/charts/tree/main/bitnami/keycloak#configure-ingress
    ingress:
      ## @param identity.keycloak.ingress.enabled can be used enable ingress record generation for Keycloak.
      enabled: false
      ## @param identity.keycloak.ingress.tls can be used to enable TLS configuration for the host defined at ingress.hostname parameter.
      tls: false
      ## @param identity.keycloak.ingress.extraTls configuration for additional hostnames to be covered with this ingress record.
      extraTls: []
      ## @param identity.keycloak.ingress.annotations [object] configures annotations to be applied to the ingress record.
      annotations:
      ## @skip identity.keycloak.ingress.annotations.nginx.ingress.kubernetes.io/proxy-buffer-size
        nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"

    ## @extra identity.keycloak.service configuration, to configure the service which is deployed along with keycloak
    service:
      ## @param identity.keycloak.service.type can be set to change the service type.
      # We use clusterIP for keycloak service, since per default LoadBalancer is used, which is not supported on all cloud providers.
      # This might prevent scheduling of the service.
      type: ClusterIP
    ## Keycloak authentication parameters
    ## ref: https://github.com/bitnami/bitnami-docker-keycloak#admin-credentials
    ##
    ## @extra identity.keycloak.auth uses the secrets generated by keycloak, to access keycloak.
    auth:
      ## @param identity.keycloak.auth.adminUser defines the keycloak administrator user
      adminUser: admin
      ## @param identity.keycloak.auth.existingSecret can be used to reuse an existing secret containing authentication information.
      # See https://docs.bitnami.com/kubernetes/apps/keycloak/configuration/manage-passwords/ for more details.
      existingSecret: ""

## @section WebModeler Parameters
# WebModeler configuration of the Web Modeler deployment
webModeler:
  enabled: false

postgresql:
  enabled: false

connectors:
  ## @param connectors.enabled if true, the Connectors deployment and its related resources are deployed via a helm release
  enabled: true

  ## @extra connectors.inbound Switch for inbound mode (e.g., for webhook or polling)
  inbound:
    ## @param connectors.inbound.mode acceptable values: disabled, credentials, or oauth
    mode: oauth
    ## @extra connectors.inbound.auth configuration of the credentials authentication.
    auth:
      ## @param connectors.inbound.auth.existingSecret can be used to configure Secret name that contains connectors password
      existingSecret: ""

  ## @extra connectors.image configuration to configure the Connectors image specifics
  # https://hub.docker.com/r/camunda/connectors-bundle/tags
  image:
    tag: 8.4.0
  replicas: 1
  resources:
    requests:
      cpu: 1
      memory: 1Gi
    limits:
      cpu: 2
      memory: 2Gi

  ingress:
    ## @param connectors.ingress.enabled if true, an ingress resource is deployed with the Connectors deployment. Only useful if an ingress controller is available, like nginx.
    enabled: false
    ## @param connectors.ingress.className defines the class or configuration of ingress which should be used by the controller
    className: nginx
    ## @param connectors.ingress.annotations [object] defines the ingress related annotations, consumed mostly by the ingress controller
    ## @skip connectors.ingress.annotations.ingress.kubernetes.io/rewrite-target
    ## @skip connectors.ingress.annotations.nginx.ingress.kubernetes.io/ssl-redirect
    ## @skip connectors.ingress.annotations.nginx.ingress.kubernetes.io/proxy-buffer-size
    annotations:
      ingress.kubernetes.io/rewrite-target: "/"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
      nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
    ## @param connectors.ingress.path defines the path which is associated with the Connectors service and port https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    path: /
    ## @param connectors.ingress.host can be used to define the host of the ingress rule. https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    # If not specified the rules applies to all inbound http traffic, if specified the rule applies to that host.
    host: ""
    ## @extra connectors.ingress.tls configuration for tls on the ingress resource https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    tls:
      ## @param connectors.ingress.tls.enabled if true, then tls is configured on the ingress resource. If enabled the Ingress.host need to be defined.
      enabled: false
      ## @param connectors.ingress.tls.secretName defines the secret name which contains the TLS private key and certificate
      secretName: camunda-platform-connectors

## Console Parameters - WARNING: Console is currently under development and should not be used yet.
console:
  enabled: false

## @extra elasticsearch
elasticsearch:
  ## @param elasticsearch.enabled
  enabled: true
  # https://hub.docker.com/r/bitnami/elasticsearch/tags
  image:
    ## @param elasticsearch.image.repository
    repository: bitnami/elasticsearch
    ## @param elasticsearch.image.tag
    tag: 8.9.2
  ## @param elasticsearch.extraVolumes[0].name
  ## @param elasticsearch.extraVolumes[0].emptyDir
  ## @param elasticsearch.extraVolumes[1].name
  ## @param elasticsearch.extraVolumes[1].emptyDir
  ## @param elasticsearch.extraVolumes[2].name
  ## @param elasticsearch.extraVolumes[2].emptyDir
  extraVolumes:
  - name: tmp
    emptyDir: {}
  - name: logs
    emptyDir: {}
  - name: config-dir
    emptyDir: {}
  ## @param elasticsearch.extraVolumeMounts[0].mountPath
  ## @param elasticsearch.extraVolumeMounts[0].name
  ## @param elasticsearch.extraVolumeMounts[1].mountPath
  ## @param elasticsearch.extraVolumeMounts[1].name
  ## @param elasticsearch.extraVolumeMounts[2].mountPath
  ## @param elasticsearch.extraVolumeMounts[2].name
  extraVolumeMounts:
  - mountPath: /tmp
    name: tmp
  - mountPath: /usr/share/elasticsearch/logs
    name: logs
  - mountPath: /usr/share/elasticsearch/config
    name: config-dir
  master:
    ## @param elasticsearch.master.masterOnly
    masterOnly: false
    ## @param elasticsearch.master.heapSize
    heapSize: 1024m
    persistence:
      ## @param elasticsearch.master.persistence.size
      size: 5Gi
    resources:
      requests:
        ## @param elasticsearch.master.resources.requests.cpu cpu request
        cpu: 1
        ## @param elasticsearch.master.resources.requests.memory request
        memory: 2Gi
      limits:
        ## @param elasticsearch.master.resources.limits.cpu cpu limit
        cpu: 2
        ## @param elasticsearch.master.resources.limits.memory memory limit
        memory: 2Gi
    extraEnvVars:
    ## @param elasticsearch.master.extraEnvVars[0].name env
    - name: ELASTICSEARCH_ENABLE_REST_TLS
    ## @param elasticsearch.master.extraEnvVars[0].value env value
      value: "false"
  sysctlImage:
  ## @param elasticsearch.sysctlImage.enabled
    enabled: true
  data:
    ## @param elasticsearch.data.replicaCount
    replicaCount: 0
  coordinating:
    ## @param elasticsearch.coordinating.replicaCount
    replicaCount: 0
  ingest:
    ## @param elasticsearch.ingest.enabled
    enabled: false

prometheusServiceMonitor:
  enabled: false